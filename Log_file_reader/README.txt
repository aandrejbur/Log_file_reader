Описание решения:

Решение написано на "C" без применения "С++", написано в программе XCode под MAC OS X 10.11.
РЕшение так же полностью работает в Linux, собирается с помощью makefile, запускалось и тестировалось на Ubuntu x64 с ядром 3.13.0-37-generic, версия gcc (Ubuntu 4.8.2-19ubuntu1) 4.8.2. Для отладки под Linux использовался valgrind.

При работе с тестовым файлом и его полным проходом (ничего не найдено) расход оперативной памяти не превышал 15 мб.
Оценить быстродействие можно условно: файл прочитывается быстрее чем открыть в виртуальной машине в блокноте. Более точных измерений не проводил.

В результате решения задания сделал приложение для разбора файлов и поиска вхождений слова для поиска(mask)
Приложение работает в трёх синхронизированных потоках одновременного выполнения.
1 - ый поток: "pthReader", запускается и инициализирует переменные, пробует открыть файл и блокирует поток поиска.
читает из файла блоки данных (при большом размере файла по 4 мб, при размере файла менее 4 мб - считывает файл целиком) считывает как с конца так и с начала.
После считывания первого блока данных, разблокирует поток поиска и  передает считанную строку в очередь поиска(очереди организованы на основе двухстороннего списка)
В случае если в очереди поиска более 10К строк, поток чтения останавливается и считает до 10000, Это необходимо для контроля расхода оперативной памяти, тогда когда поиск по долгу не может найти строки определенного вхождения.
После полного прочтения файла поток останавливается.
И во флагах общей переменной устанавливает значение конца файла.
В случае ошибки в процессе выполнения потока считывания, он так же устанавливает флаг ошибки и заканчивает работу.

2-ой поток: pthSearcher, запускается инициализирует переменные и блокирует поток записи в исходящий буфер до тех пор пока не будет найдена хотя бы одна подходящая строка (или же до конца файла или возникновения ошибки), поток принимает строки из очереди поиска(plSearchQueue), и ищет с помощью библиотеки regex вхождение строки "Mask" в считанную строку.
Для осуществления поиска по регулярным выражениям, я применил маленькую хитрость и просто подменяю символы "*" и "?" на пустой символ и символ "." соответственно.
Строки в которых обнаружено вхождение передаются на 3-й поток, строки помещаются в очередь, а 3-й поток предварительно разблокируется.
В случае когда обрабатывать больше нечего и файл прочитан полностью (или же возникла ошибка) поток устанавливает флаг "Search_is_done" в 1, и заканчивает работу.
Если до конца работы потока 3-й поток не был разблокирован, производится разблокировка 3-его потока.

3-й поток: "pthWriter" запускается, инициализирует внутренние переменные и принимает из очереди "plWrightQueue" строки, при принятии строки поток проверяет куда записывать результат (сделал в файл или вывод на экран просто писать в буфер не целесообразно теряется смысл существования потока). При достижении максимального числа записей поток устанавливает в единицу флаг "iMax_lines", и завершает работу.

Потоки синхронизируются с помощью 3-х мьютексов. 2 из них для взаимодействия с очередями и один для проверки флагов.
Для организации очередей сделал небольую библиотеку (list_t).

Прграмма может выполняться в двух режимах:
1-ый режим - режим генерации файла. Запуск программы без параметров командной строки приводит к генерации тестового файла размером 2,2ГБ.

2-ый режим - режим поиска вхождений строк.
Параметры командной строки принимаемые программой:

-f='file_path' - передается путь к файлу
-m='mask' - маска для поиска возможны следующие варианты: 'mask','*mask','mask*','*mask*','?mask','mask?','?mask?'. а так же комбинации "*" и "?" в разных концах. Поиск Регистрозависим
-c='max_lines' - максимальное количество линий
-d='scan_tail' - направление поиска по файлу (0 - прямое, 1 - обратное)
-o='output'    - вывод (0 - на экран консоли, 1 - в файл (создается файл Result.txt))
-s='separator' - разделитель результирующих строк поиска (по умолчанию добавляется '\n')
-h 			   - Вывод помощи и инструкции на экран.

Большое спасибо за интересное задание.

С уважением, Буренков Андрей Радикович.
+375 (33) 632-42-78




CC 			= 	gcc -pthread
CFLAGS 		= 	-Wall
LDFLAGS 	=   # linking flags
SOURCES 	= 	main.c list_t.c usefull_utilities.c
OBJECTS 	= 	$(SOURCES:.c=.o)
EXECUTABLE 	= 	log_reader

.PHONY: all
all:  $(SOURCES) $(EXECUTABLE)

$(EXECUTABLE): $(OBJECTS)
$(CC) $(LDFLAGS) $(OBJECTS) -o $@

.cpp.o: \
$(CC) $(CFLAGS) $< -o $@

.PHONY:	clean
clean:
rm -rf *.o  log_reader
