Описание решения:

Решение написано на "C" без применения "С++", написано в программе XCode под MAC OS X 10.11.
РЕшение так же полностью работает в Linux, собирается с помощью makefile, запускалось и тестировалось на Ubuntu x64 с ядром 3.13.0-37-generic, версия gcc (Ubuntu 4.8.2-19ubuntu1) 4.8.2. Для отладки под Linux использовался valgrind.

При работе с тестовым файлом и его полным проходом (ничего не найдено) расход оперативной памяти не превышал 10 мб.
Время на полный проход (ничего не найдено) тестового файла составило ~ 1минута

В результате решения задания сделал приложение для разбора файлов и поиска вхождений слова для поиска(mask)

Приложение работает в трёх синхронизированных потоках одновременного выполнения.
1 - ый поток: "pthReader", запускается и инициализирует переменные, пробует открыть файл.
Читает из файла блоки данных (при большом размере файла по 4 мб, при размере файла менее 4 мб - считывает файл целиком) считывает как с конца так и с начала.
После считывания первого блока данных, передает считанную строку в очередь поиска(очереди организованы на основе двухстороннего списка) и увеличивает семафор для потока поиска. В случае если в очереди поиска более 10К строк, поток чтения останавливается на 1000 мкС, Это необходимо для контроля расхода оперативной памяти, тогда когда поиск по долгу не может найти строки определенного вхождения. (После отказа от regex для поиска таких случаев не было)
После полного прочтения файла поток закрывает файл и увеличивает семафор потока поиска, а так же устанавливает флаг iFile_end в состояние 1 и останавливается.
И во флагах общей переменной устанавливает значение конца файла.
В случае ошибки в процессе выполнения потока считывания, он так же устанавливает в 1 флаг ошибки (iError) и заканчивает работу.

2-ой поток: pthSearcher, запускается инициализирует переменные, создает структуру для поиска (psSearch) и ожидает увеличения семафора поиска. поток принимает строки из очереди поиска(plSearchQueue), и ищет с помощью библиотеки (search_lib) вхождение строки "Mask" в считанную строку.
Для осуществления поиска по регулярным выражениям,

Строки в которых обнаружено вхождение передаются на 3-й поток, строки помещаются в очередь после чего увеличивается семафор потока записи.
В случае когда обрабатывать больше нечего и файл прочитан полностью (или же возникла ошибка) поток устанавливает флаг "Search_is_done" в 1, и заканчивает работу, увеличивая перед этим семофор потока записи.

3-й поток: "pthWriter" запускается, инициализирует внутренние переменные и ожидает увеличения семофора записи. При увеличении семафора поток принимает из очереди "plWrightQueue" строки, после принятия строки поток проверяет куда записывать результат (сделал вывод в файл или вывод на экран, просто писать в буфер не целесообразно теряется смысл существования потока). При достижении максимального числа записей поток устанавливает в единицу флаг "iMax_lines", и завершает работу.

Потоки синхронизируются с помощью 3-х мьютексов и 2-ух семафоров.
Для организации очередей сделал небольую библиотеку (list_t).

Прграмма может выполняться в трех режимах:
1-ый режим - режим генерации файла. Запуск программы без параметров командной строки приводит к генерации тестового файла размером 2,2ГБ.

2-ый режим - режим поиска вхождений строк.
Параметры командной строки принимаемые программой:

3-ий режим - показ справки по программе.

-f='file_path' - передается путь к файлу
-m='mask' - маска для поиска возможны следующие варианты: 'mask','*mask','mask*','*mask*','?mask','mask?','?mask?'. а так же комбинации "*" и "?" в разных концах. Поиск Регистрозависим
-c='max_lines' - максимальное количество линий
-d='scan_tail' - направление поиска по файлу (0 - прямое, 1 - обратное)
-o='output'    - вывод (0 - на экран консоли, 1 - в файл (создается файл Result.txt))
-s='separator' - разделитель результирующих строк поиска (по умолчанию добавляется '\n')
-h 			   - Вывод помощи и инструкции на экран.

Относительно первого высланного решения изменил:

1 - обработку вызова справки (не было обработки конца и происходила ошибка)
2 - считывание с конца ( на поиск не отправлялась последняя строка)
3 - реализовал поиск по регулярным выражениям ( отказался от regex потому что он очень медленный, полученный поиск работает быстрее почти в 4-ре раза, но работает корректно только с английским языком, если потребуется могу добавить поддержку русского языка)
4 - добавил в синхронизацию семафоры (дабы не гонять процессор впустую всеми тремя потоками)

Большое спасибо за интересное задание.

С уважением, Буренков Андрей Радикович.
+375 (33) 632-42-78





CC 			= 	gcc -pthread
CFLAGS 		= 	-Wall
LDFLAGS 	=   # linking flags
SOURCES 	= 	main.c list_t.c usefull_utilities.c
OBJECTS 	= 	$(SOURCES:.c=.o)
EXECUTABLE 	= 	log_reader

.PHONY: all
all:  $(SOURCES) $(EXECUTABLE)

$(EXECUTABLE): $(OBJECTS)
$(CC) $(LDFLAGS) $(OBJECTS) -o $@

.cpp.o: \
$(CC) $(CFLAGS) $< -o $@

.PHONY:	clean
clean:
rm -rf *.o  log_reader
